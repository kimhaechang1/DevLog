# Dec. 03. 2022 commit

적용 프로젝트 : [bePro](https://github.com/kimhaechang1/bePro)

작성 날짜 : Dec. 05. 2022

## 개발 내용
> ### QnA 게시판 구현
>
> 참고자료
>
> [React-router-dom v6 tutorial](https://velog.io/@velopert/react-router-v6-tutorial)
>
> [react-router](https://reactrouter.com/en/main)
> 
> 게시판 구현을 위해 필요한 파일을 먼저 설계하고
>
> 최소한의 기능을 갖추기 위한 구현을 하였다.
>
> 우선에 어떤 라우팅을 기준점으로 잡을지가 중요했는데, 
> 
> 이부분에 대한 지식보충을 위해 공식문서와 위의 링크를 참고하였다.
>
> **라우팅 기준**
>
> 현재 bePro 프로젝트의 게시판 역할은 크게 공지사항(notice)와 QnA게시판(QnABoard)로 나뉜다.
>
> 그리고 난 다음 각각의 게시글 뷰 페이지, 게시글 쓰기, 그리고 게시글 수정, 게시글 목록이 있다.
>
> 여기서 라우팅을 어떻게 연결할지만 거의 이틀을 여러 테스트를 통해 고민한 끝에 결정했다.
>
> 모든 게시판 라우팅은 헤더를 포함한 라우팅으로 부터 해당 게시판 리스트와 뷰 페이지로 이어진다.
>
> <img width="100%" height="100%" src="https://user-images.githubusercontent.com/81299056/205581020-24fc5b29-04e3-44ad-96d0-61a706478690.gif"/>
>
> ```jsx
> <Router>
>    <Routes>
>       <Route path="/notice" element={Gongji.js}> // localhost:3000/notice -> 공지사항 게시판 헤더
>         <Route index element={GongjiList.js}/> // 위의 링크를 타면 결국 공지사항 리스트로 오게됨
>         <Route path=":id" element={GongjiView.js}/> // localhost:3000/notice/1 -> 게시글 1번을 눌렀을 경우
>        </Route>
>    </Routes>
>  </Router>
> ```
> 여기서 react-router-dom v6 의 <Outlet/> 컴포넌트를 활용하여 중복되어지는 내용을 깔끔하게 처리한다.
>
> > **Outlet 컴포넌트**
> > 
> > ```<Outlet/>``` 컴포넌트는 중첩된 라우팅구조에서 
> > 
> > 부모 라우트 컴포넌트에 자식 라우트 컴포넌트를 랜더링할 때 쓸 수 있다.
> > 
> > 위와 같은 상황일 때에는 결국 풀어서 생각하면 
> > 
> > ```Gongji.js```의 렌더링 함수에 ```GongjiList.js```, ```GongjiView.js``` 컴포넌트가 들어 가 있게 됨으로서
> > 
> > 중복되는 레이아웃을 깔끔하게 처리 할 수 있다.
>
> 그리고 쓰기 부분은 ```Write.js``` 컴포넌트에서 ```useNavigate```함수의 파라미터를 넘겨받음으로서 
>
> 어떤 게시판인지 와 새 글쓰기인지 수정인지를 구분한다.
>
> 여기서 공지사항은 어드민 인증을 해야 글 수정 및 쓰기가 가능하고
>
> 일반 QnA 글은 회원만 새글쓰기가 가능하며, 수정일 경우 해당 글을 쓴 사람이 맞는지 검증해야 한다.
>
> ```jsx
> useNavigate('/write',{state : {
>   board : 게시판 종류(notice or qna), 
>   type : 쓰기 종류 (새글 : new or 수정 : edit), 
>   data : 수정 인 경우 데이터
>   }})
>```
>
> 라우팅 기준을 전부 정하고 나서, 실제 라우팅 구현 테스트 까지 마친 후
>
> QnA에 대한 게시판 글쓰기, 수정, 리스트불러오기, 뷰페이지 구현을 하였다.
>
> 현재로서는 프론트 작업을 먼저 처리하고 테스트를 하기 위해서
>
> 로컬 스토리지를 이용하였다.
>
> ```
> 로컬스토리지 사용방식
>
> 로컬스토리지에 글들을 "post_인덱스번호" 방식의 key값을 적용시켜 저장한다.
>
> value값으론 오브젝트 타입의 구조를 JSON화 시킨것으로 
>
> 그 내용은 아래와 같이 저장된다.
> 
> title : 글제목
> tag : 태그리스트
> context : 글내용
> date : 글쓴 날짜
> ```
>
> **QnABoard.js**
>
> 이곳에는 아까 전 설계했던 대로
>
> QnA관련 컴포넌트들의 공통요소가 들어 갈 예정이므로
>
> 지금은 우선 과거에 만들어주었던 ```<Header/>``` 헤더 컴포넌트만을 추가했다.
>
> **axiosGetQnATitle.js**
>
> 기존의 ```axiosGetQnATitle.js```는 메인 페이지의 ```<Card/>```컴포넌트에 내용을 채워줄 함수인데,
>
> 이 함수의 재사용을 잘 한다면 ```QnABoardList.js```에서도 충분히 잘 사용할 수 있을것 같다는 생각이 들었다.
>
> 따라서 기존의 제목, 조회수, 글쓴날짜만 긁어오는 방식에서 
> 
> 태그배열, 글쓴사람 아이디, 글쓴사람 닉네임, 글내용, 고유인덱스 번호까지 긁어오도록 변경하였다.
> 
> 현재상황에서는 ```.catch```를 통해 로컬스토리지에서 글들만 잘 긁어올 수 있도록 구현하였다.
> 
> **QnABoardList.js**
> 
> /qna 라우트를 통해 들어오면 처음 내용으로서 보여질 컴포넌트로서
>
> QnA게시판 글 리스트를 표현하는 페이지이다.
> 
> 글 제목을 전부 ```useNavigate``` 사용하여 글 상세보기 페이지(```QnAView.js```)로 넘어가도록 유도한다.
>
> 데이터는 ```axiosGetQnATitle```함수를 사용하여 받아오고 
>
> 응답 프로미스 객체를 분석하여 필요한 데이터를 
> 
> ```useNavigate```의 파라미터 전달 기능을 사용하여 ```QnAView.js```에 넘긴다.
>
> 따라서 사용자가 리스트 중 글 하나를 클릭했을 때 
>
> ```QnAView.js```에 해당 글 데이터가 함께 넘어가 뷰 페이지를 볼 수 있게 된다.
>
> **QnAView.js**
>
> /qna/:id 로서 해당 글 의 고유인덱스번호를 통해 각각의 뷰 페이지가 구분되어진다.
>
> 이전 ```QnABoardList.js```페이지로 부터 넘겨받은 데이터의 상세 내용을 보여주는 역할을 수행한다.
>
> 여기서는 해당 글 수정을 할 수 있는 버튼이 보여지게 되는데
>
> 아직 로그인 인증부분이 미구현 상태이기 때문에 
>
> 누구나 수정이 가능하도록 테스팅 버튼만의 기능을 수행한다.
>

> ### 글 쓰기와 수정을 담당하는 Write.js 구현
>
> Write의 역할은 아까도 설계했듯이
> 
> ```useNavigate```를 통해 넘어온 state값에 따라 달라진다.
>
> 여기서 게시판에 따라 달라지는 부분은 아마 HTML태그의 구성요소 일 것으로 예상된다.
> 
> 예를 들자면 일반 QnA 글쓰기에서는 사용자가 태그를 추가 할 수 있지만
> 
> 공지사항 글에서는 태그가 없다.
> 
> 이러한 구성요소측면에서의 차이점을 두는건 CSS를 통해 두려고 한다.
> 
> 그 밖의 달라지는 요소는 수정이냐 새글쓰기 이냐 차이인데,
>
> 새 글일 경우에는 깔끔한 상태의 ui만을 제공하면 되지만,
> 
> 글 수정일 경우 이전의 글 내용상태가 input 태그의 value값에 추가 되어있어야 한다.
>
> 이러한 요소를 바탕으로 서버에 전송될 api 숫자도 총 4개이고 함수는 2가지이다.
>
> 먼저 통신 함수부터 필요한 통신함수를 구현하고 ```Write.js``` 구현을 이어나갔다.
>
> **axiosPost.js**
>
> ```axiosPost.js```는 기본적으로 오브젝트 형태의 body값과 어떤 게시판인지를 구분하는 board값을 받아서
>
> 서버에 새 게시글을 전송하는 역할을 수행한다.
>
> 여기서는 로컬스토리지를 통해 구현 테스팅을 할 것이므로
>
> 로컬 스토리지에 데이터가 아예 없으면 ```post_1```부터 인덱싱 하도록 하고
>
> 이미 좀 쌓여있다고 판단되면 최고 인덱스 번호를 알아내어 인덱싱하여 저장하도록 구현한다.
> 
> **axiosPostUpdate.js**
>
> ```axiosPostUpdate.js```의 파라미터는 ```axiosPost.js```와 동일하게 수행되고
>
> 서버에 수정된 글을 업데이트 하는 역할을 수행한다.
>
> 여기서는 위와 마찬가지로 로컬스토리지를 통해 역할을 수행하므로
>
> 기존의 글을 고유인덱스 번호를 통해 찾아서 삭제하고 수정된 글을 저장하는 방식을 구현한다.
>
> **Write.js**
> 
> 먼저 해당 컴포넌트의 핵심 요소 세가지의 input태그와 
>
>글 태그용 ```<HashTag>```컴포넌트를 랜더링 할 요소로 추가한다.
>
> ```HTML
> <input type="text" name="contentTitle"/> // 글 제목
> <HashTag/> // 태그를 렌더링할 컴포넌트
> <input type="text" className="tagInput"/> // 태그 입력태그
> <input type="textarea"> // 글 내용  
> ```
> 
> 
> 아까 넣어준 input태그들에 대한 ```state```와 ```<HashTag>```컴포넌트의 재사용을 위한
>
> 태그배열 state를 ```useState``` 리액트 훅을 통해 저장 한다.
>
> ```jsx
> const [contentTitle, setContentTitle] = useState("");
> const [tag, setTag] = useState([]);
> const [context, setContext] = useState("");
> ```
> 그리고 ```useLocation ```훅을 통해 이전 리스트에서 ```useNavigate```로 넘어온 state가 있다면
> 
> ```useEffect```내부에서 ```setState```를 통해 ```input```태그들의 ```value```를 채워주도록 한다.
> 
> 이렇게 함으로서 글 수정인 경우에 미리 받아온 데이터를 사용자에게 수정하도록 제공할 수 있다.
>
> 마지막 ```Submit```버튼을 누를 경우 onClick이벤트를 통해
>
> 각종 state데이터들을 ```axiosPost```함수의 인자로 넣도록 구현한다.
>
> 여기서 오브젝트 값 중 index부분은 원래는 서버에서 관리하는데 (autoincrement)
> 
> 새 글인경우 로컬스토리지를 사용 할 때 인덱스번호를 계산하여 저장한다.
> 
> 그리고 응답 프로미스 객체를 분석하여 잘 전달되었는지에 대한 메시지를 ```alert```하도록 구현한다.
> 
> **HashTag.js의 재사용**
> 
> 참고자료
>
> [How to remove the border highlight on an input text element](https://stackoverflow.com/questions/1457849/how-to-remove-the-border-highlight-on-an-input-text-element)
>
> [Input 입력폼 엔터키 누를 경우 Submit 막기, Prevent](https://webisfree.com/2017-08-07/input-%EC%9E%85%EB%A0%A5%ED%8F%BC-%EC%97%94%ED%84%B0%ED%82%A4-%EB%88%84%EB%A5%BC-%EA%B2%BD%EC%9A%B0-submit-%EB%A7%89%EA%B8%B0-prevent)
>
> 태그 기능을 재사용하기 위해서 이전에 검색을 구현할 때 사용했던
>
> ```<HashTag>```컴포넌트를 재사용 하게 되는데
>
> 이 때 필요한 state로서 태그 배열이 필요하므로 앞선 구현에서 구현하였다.
>
> 또한 이 때에는 사용자의 input값을 검사하여 엔터키를 눌렀을 경우 
>
> 태그 리스트에 태그를 추가하도록 구현하기 위해서 ```onkeyUp``` 이벤트 리스너를 연결한다.
>
> 여기서 중복태그가 존재하는지 검사또한 진행한다.
> 
> 그리고 핵심 기능으로서 태그가 엔터침과 동시에 추가되고
>
> 그와 동시에 태그를 입력받는 input태그가 옆으로 살짝 밀려지도록 구현하였다.
>
> 근데 여기서 엔터를 쳤을 때 onKeyUp 이벤트가 발생하는 것이 아닌 submit버튼이 계속 눌려지는것이었다.
> 
> 그래서 나중에 구글링을 해보니 ```<form>``` 감싼 부분을 없애면 된다고...
>
> 따라서 ```<form>```태그로 기본적으로 감싸준 부분을 없애주었다.
>
> 그 밖의 구현 사항으로는 CSS에서 input태그를 눌렀을 때 태두리가 굵어지는걸 삭제하였다.
>
> 다음은 최종시연 Gif 파일이다.
>
> <img width="100%" height="100%" src="https://user-images.githubusercontent.com/81299056/205599351-f11701f6-ac0c-4ab9-b1f1-608ee0683b77.gif"/>
  
  
<br>

> ### 그 밖의 핵심 수정사항들
> 
> **로그아웃 통신 문제**
>
> 처음 구상했던 방식이 쿠키를 사용했던 방식을 들고왔던지라
>
> 서버에 아이디값 하나를 전송해야 하는걸 잊어버렸다.
>
> 따라서 로그인 할 때 로컬스토리지에 저장되는 값에 사용자 아이디를 추가 하였고
> 
> 그곳에 저장된 아이디를 들고와서 정상적으로 로그아웃하도록 변경하였고
>
> 또한 새로고침 하는 구문을 ```axiosSignOut```에 추가하였다.
> 
> **라우팅 네임 대문자에서 소문자로 변경**
>
> 기존의 라우팅 네임들이 전부 대문자 카멜체로 되어있는데
>  
> 이부분을 그냥 소문자로 바꿨다.
>
> **axiosSearch.js에 응답 데이터 리턴값 수정**
>
> ```.then``` 을통해 response.data를 리턴해야하는데 까먹고 안만들어 준듯 하다.
>

후기
  
정말 이틀동안 빡세게 고민했던것 같다.
  
"어떻하면 최대한 Write.js하나로 해결할 수 있을까?" 나 "어떻하면 Board.js하나로 게시판 기능을 수행시킬 수 있을까?"를 고민했었다.
  
 결국 정답은 내가 react-router-dom v6대한 지식 부족이었는걸 알고 나서는
  
 빠르게 프로젝트에 적용시키려고 하면서도 최대한 하나하나 레퍼런스를 보며 공부했다.
  
 다음에 한번 리액트를 총정리 할 때가 있을탠대, 그때 재대로 한번 공부하면 나의 것으로 만들 수 있을것 같다.
