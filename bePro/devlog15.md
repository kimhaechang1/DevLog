# Dec. 12. 2022 commit

적용 프로젝트 : [bePro](https://github.com/kimhaechang1/bePro)

작성 날짜 : Dec. 13. 2022

## 개발 내용
> ### API테스트 및 문제점 발견
>
> #### API 테스트
> 
> 테스트는 아래의 내용을 진행했다.
>
> **검색기능 테스트**
> + 검색어와 해쉬태그가 함께 잘 검색되는지
> + 검색어와 해쉬태그가 독립적으로 잘 검색되는지
>
> **최신QnA 글 구하기**
> + 이 부분은 현재 ```QnABoardList```에서도 함께 사용 할 예정
> + 추가적인 요소는 추 후 고려(개수, API 분리 등)
>
> **최신 순 공지사항 글 구하기**
> + 위의 최신QnA 글 구하기와 동일
> 
> **QnA 글 조회수 내림차순으로**
> + 조회수 순으로 10개만 잘 넘어오는지
>
> **해쉬태그 순위**
> + 게시글에 사용된 해쉬태그들을 중복없이 사용된 횟수로 내침차순 된 데이터 
>
>
> #### 문제점 발견
>
> 여러 API를 테스트 하며 문제점을 발견했다.
>
> **1. 메인 페이지 ```Card```컴포넌트에 내용으로 쓰일 API가 너무 다양화 되어있다.**
>
> 이 부분은 현재 공지사항 글 제목, QnA글 제목, 그리고 QnA 조회수 순 글 제목 이라는 세 가지 API를 사용하는데
>
> 굳이 이렇게 세 가지로 나눌필요 없이, 조회수순을 제외하고 두 가지로 나누는 것 이다.
>
> **2. 또한 현재 ```QnABoardList```와 메인 페이지 ```Card```에서 쓰이는 API가 동일하다.**
> 
> 이 부분은 최신 글 10개를 들고오는걸 임시방편으로 같은걸 들고오도록 해놓았는데,
>
> API를 확실히 분리할까 말까 고민을 하였고
>
> 회의를 통해 얻은 결론을 지었다.
> 
> 1번과 2번은 API를 분리를 하되, 게시판 종류에 대한 부분은 body에 담아서 보내도록 한다.
>
> **3. 현재 URL에 직접 파라미터를 입력하여 접속을 시도 할 시 404를 띄운다.**
>
> 사실 이 3번이 핵심 사항인데
>
> 이러한 문제가 발생 한 이유는 글 목록을 불러 올 때,
>
> 해당 글 제목 뿐만아니라 상세 모든 데이터를 불러와서
>
> 미리 각 글 제목별로 ```useNavigate```의 ```state```를 통해 상세 내용을 넘겨주기 때문이다.
>
> 아래는 해당 구조로 된 ```QnABoardList```이다.
>```jsx
> //...
> const navigate = useNavigate();
> // data : axiosGetQnATitle()을 통해 얻은 데이터
> const onLinkHandler = () => {
>   navigate(`/qna/${data['index']}`,{state : {
>     "title" : data['title'],
>     "tag" : data['tag'],
>     "context" : data['context'],
>     "views" : data['views'],
>     "date" : data['date'],
>     "index" : data['index']
>   })
> }
> return (
>   <div onClick={onLinkHandler}>1번 qna 글 제목</div>
> )
>```
> 그래서 해당 구조로인해 무조건 사용자는 글목록을 거쳐야만 상세보기가 가능하다.
>
<br>

> ### 구조 개선
> #### 라우트 구조개선 
>
> 우선 기본적으로 공지사항 페이지에 대한 라우팅 연결을 해주었다.
>
> 방식은 QnA와 동일한 방식을 가진다.
>
> 여기서 각각의 검색결과 페이지를 나타낼 ```/search``` 루트를 중첩 라우팅으로 추가한다.
>```jsx
> <Router>
>   <Routes>
>    <Route path="/notice" element={<NoticeBoard/>}>
>     <Route index element={<NoticeBoardList/>}/>
>     <Route path=":id" element={<NoticeView/>}/>
>     <Route path="search" element={<NoticeResult/>}/>
>    </Route>
>   <Routes>
> </Router>
>```
>
> #### API역할 통합 및 분리
>
> **공통 관심사 통합**
> 
> ```Card```컴포넌트를 통해 나타내는 3요소를
>
> 기능의 공통점이 있는 것을 기준으로 나누면
> 
> ```axiosGetQnATitle```이랑 ```axiosGetGongjiTitle```은 동일하다.
>
> 따라서 이 두가지를 ```axiosMainBoard```로 묶는 대신 인자로 넘어온 게시판 종류를 서버에 보내어
>
> 두 가지 다른 내용을 리턴받도록 조정 하였다.
> 
> 여기서 
> 
> ```axiosMainBoard```에서는 boardType을 넘겨받아서 그대로 object화 시키고
>
> 서버로 전송하여 공지사항 혹은 QnA에 해당하는 데이터를 받아서 리턴시킨다.
> 
> 이에따라 bind함수도 변경되어야 하는데
>
> 기존의 bind함수는 Card컴포넌트의 props로 넘어온 title을 기준으로 
> 
> 제목에 맞는 axios 함수를 리턴 해주었는데
>
> 이제는 게시판의 종류도 함께 리턴되어야 하고, 메서드를 나누는 기준도 제목이 아닌
>
> 기능을 기준으로 나눈다.
>
>```jsx
> // 기능으로 보았을 때에는 정렬 기준이 다른 axiosGetViewTitle을 제외하고 
> // 두 개가 동일하므로, if문을 통해 "조회수 높은 순"만을 걸러낸다.
> // 이 부분은 추 후 더 길어질 수 있으나, bind 함수가 무거워 지는건 나중에 고려한다.
> const bindCardContent = (type) =>{
>    const method = {
>        "조회수 높은 순" : "qna",
>        "최신 QnA" : "qna",
>        "공지사항" : "notice"
>    }
>    if(type ==="조회수 높은 순"){ 
>        return {
>            boardType : method[type],
>            method : axiosGetViewTitle   
>        }
>    }else{
>        return {
>            boardType : method[type],
>            method : axiosMainBoard
>        }
>    }
>}
>```
> 마지막으로 Card.js에서는 ```useEffect``` 훅에서
> 
> bind함수를 통해 얻는 boardType과 전용 메서드를 사용하는데
>
> 이 때, boardType의 값은 랜더링 되어질 요소에 navigate 함수에 사용 될 예정이기에
> 
> useState로 관리한다.
>
> 그 밖의 과정으로는 bind 함수에서 리턴받은 메서드에 게시판 종류를 인자로 넣어 실행시키고
> 
> 리턴받은 글 데이터를 ```.then``` 상태설정함수(```setState```)로 저장 한다.
>
> 마지막으로 각각의 글들을 눌렀을 때 상세보기 페이지로 바로 넘어가도록 ```navigate```함수를 구성하는데
> 
> 이 때 url파라미터로 해당 글의 고유 인덱스 번호를 넘긴다.
> 
>```jsx
> <div onClick={()=>{navigate(`/${boardType}/${data['id']}`)}}></div>
>```
> 
> **기능 별 분리**
>  
> 기존의 QnA 리스트를 불러오는 방식은 같은 API를 사용하였다.
>  
> 하지만 이 방식은 결국 같은 개수를 불러오는데에 대한 문제가 발생하고
>
> 더 나아가서 사용하는 컴포넌트도 Card컴포넌트와 게시판 컴포넌트로 달라진다.
>
> 따라서 위에 정의 한 ```axiosMainBoard```와 ```axiosGetViewTitle.js``` 두가지를 Card컴포넌트용으로 사용하고
> 
> 각각의 게시판별 리스트는 ```axiosBoardList```로 관리한다.
> 
> ```axiosBoardList```는 게시판 종류를 body에 실어서 서버에 보내고
> 
> 서버에서는 상황에 따라 구분된 응답 데이터를 보내준다.
> 
> 이에 따라 리턴받은 객체에 ```.then```을 통해 필요한 부분을 useState를 사용하여 저장하고
> 
> useState에 있는 데이터를 렌더링 할때 사용한다.
> 
> 여기서도 마찬가지로 상세보기 페이지로 넘어갈 때
>
> useNavigate를 통해 url파라미터로 고유인덱스를 넘긴다.
> 
> #### 상세보기 페이지의 url파라미터 사용기
>
> 참고자료 
> 
> [useParams](https://reactrouter.com/en/main/hooks/use-param)
>
> 이제 상세보기 페이지에서 url파라미터로 넘어온 고유 인덱스 값을 사용해야 한다.
> 
> 사용하는 곳은 ```axiosBoardView``` 함수로서, 인덱스 값과 게시판 종류를 입력 받아서 
> 
> 게시글에 대한 상세 내용을 리턴시킨다.
>
> 그렇게 리턴받은 상세내용을 ```useState```훅을 사용하여 저장 한 뒤 
> 
> 렌더링 할 때 해당 데이터를 사용하면 된다.
  
<br>
  
> ### 버그 및 자잘한거 수정
>
> #### 로그아웃 진행 시 브라우저 토큰이 삭제 안되는 버그 발생
> 
> 원인 : 
> 기존의 ```window.location.reload()```가 로직상 가장 아랫단에 두어있었는데
>
> 그 이유는 로그아웃에 성공했을 경우나 이미 로그아웃된 상태인데 브라우저상에 로그아웃 버튼이 있을 경우엔
>
> 공통적으로 페이지 리로딩을 통해 해결 하기 때문이다.
> 
> 근데 통신을 통해 백엔드에 ```post``` 요청을 하는 과정은 비동기적이므로 
>
> 예상했던 결과와는 다르게 정상 로그아웃의 경우 
>
> ```.then```이후 과정을 처리하기 전에 if문 절차가 끝나버리는 것이다.
>
> 따라서 request.then 처리과정 이후 와 이미 로그아웃 된 상태 일 경우에 각각 
>
> ```window.location.reload()```을 실행하도록 정의 했다.
>
> 그렇게 진행 했더니, 아무문제 없이 잘 실행 되었다.

후기

처음에 백엔드 로직이 일부 완성되어서 즐겁게 테스트 하려고 했는데
  
처음 로그인 로그아웃부터 문제가 생겼을 줄이야 심상치 않았다.
  
심지어 겉으로 보기엔 문제가 없어 보였던게 시간을 좀 더 소비하게 만들었었는데
  
역시 비동기함수는 처리할때 조심해야 한다.
  
또한 url 파라미터 문제도 참 처음에는 고민 많이 하면서 내보낸 설계였는데
  
처음에는 뭐 설마 url 파라미터로 접근하는 사람이 있겄나 했는데,
  
다른 게시판들은 다 url 파라미터로 접근해도 문제없이 잘 작동하던 것이었다.
  
역시 어떤 경우의수든 잘 작동되게 하는게 사용자 친화적이라고 생각하는게 맞는것 같다.
